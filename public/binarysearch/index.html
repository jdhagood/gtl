<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Binary Search | GTL Python</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About Me</a></li>
      
      <li><a href="/enviroment_model/">Enviroment Diagram</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Binary Search</span></h1>


</div>

<main>
<h1 id="conditionals">Conditionals</h1>
<p>Because we want our python programs to be more than glorified calculators, we need a way to conditially executing code</p>
<h1 id="where-did-we-leave-the-keys">Where did we leave the keys?</h1>
<p>Last summer my friends and I had a rented a Christler Pacifica that we endearingly named &ldquo;Chrissy&rdquo;.</p>
<style>
    .soft {
        width: 600px;
        border-radius: 10px;
        display: block;
        margin: 0 auto;  
    }
    .image-container {
        text-align: center;
        margin: 20px 0;  
    }
    .caption {
        font-size: 0.9em;
        color: #555;  
        margin-top: 10px;
    }
    .caption a {
        color: #007BFF;  
        text-decoration: none;  
    }
    .caption a:hover {
        text-decoration: underline;  
    }
</style>

<div class="image-container">
    <img src="/img/binarysearch/chrissy.jpg" class="soft" alt="Soft-styled image">
    
    <div class="caption">
        Chrissy!
    </div>
    
</div>

<p>One day we realized that we lost Chrissy&rsquo;s keys. We were fairly certain that the keys ended up in one of our bags, but there were quite a few of us with many differnt bags. It would take all day to go through them. Thankfully, the car had electroic ignition system, so you could start the car if the keys were anywhere inside the car.</p>
<p>As a bunch of MIT students, we thought back to our intro CS classes and knew this problem could be solved most efficiently with a binary search! We put half of our luggage in Chrissy and pressed the ignition. The car did not start, so we immediatly know that half of the luggage did not have the keys cutting our search space in half.</p>
<p>Next we put half of the remaing luggage into the car and pressed the ignition. It started up so we knew the keys were in that half of the luggage. We then took out half the luggage we put in the car and tried the ignition again.</p>
<p>We repeated this process of narrowing down which bags could possible have the keys in them based on if the car started up until we were left with only one possible bag for the keys to be in. After a quick search in this bag we found the keys!</p>
<h2 id="a-pythonic-implementation">A pythonic implementation</h2>
<p>Lets see if we can implement this algorithm in python. We could write something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff6ac1">def</span> <span style="color:#57c7ff">find_bag_with_keys</span>(number_of_bags, car_start):
</span></span><span style="display:flex;"><span>    <span style="color:#5af78e">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    Finds the bag with the keys using a binary search approach.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    Parameters:
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    - number_of_bags (int): Total number of bags.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    - car_start (function): A function that takes a list of bag indices and returns
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">      True if the keys are in one of those bags (the car starts), False otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    Returns:
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    - int: The index of the bag containing the keys.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#78787e"># Define the initial search range</span>
</span></span><span style="display:flex;"><span>    left <span style="color:#ff6ac1">=</span> <span style="color:#ff9f43">0</span>
</span></span><span style="display:flex;"><span>    right <span style="color:#ff6ac1">=</span> number_of_bags <span style="color:#ff6ac1">-</span> <span style="color:#ff9f43">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">while</span> left <span style="color:#ff6ac1">&lt;</span> right:
</span></span><span style="display:flex;"><span>        <span style="color:#78787e"># Calculate the midpoint of the current search range</span>
</span></span><span style="display:flex;"><span>        mid <span style="color:#ff6ac1">=</span> (left <span style="color:#ff6ac1">+</span> right) <span style="color:#ff6ac1">//</span> <span style="color:#ff9f43">2</span> <span style="color:#78787e"># //2 rounds down in the case left + right is odd</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#78787e"># Test the car with the first half of the current range</span>
</span></span><span style="display:flex;"><span>        bags_to_test <span style="color:#ff6ac1">=</span> <span style="color:#ff5c57">list</span>(<span style="color:#ff5c57">range</span>(left, mid <span style="color:#ff6ac1">+</span> <span style="color:#ff9f43">1</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">if</span> car_start(bags_to_test):
</span></span><span style="display:flex;"><span>            <span style="color:#78787e"># Keys are in the left half inside the car</span>
</span></span><span style="display:flex;"><span>            right <span style="color:#ff6ac1">=</span> mid
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#78787e"># Keys are in the right half outside the car</span>
</span></span><span style="display:flex;"><span>            left <span style="color:#ff6ac1">=</span> mid <span style="color:#ff6ac1">+</span> <span style="color:#ff9f43">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#78787e"># Return the index of the bag containing the keys</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">return</span> left
</span></span></code></pre></div><p>In this function, we initialize two pointers, <code>left</code> and <code>right</code>, to keep track of our search window. All the bags are numbered and those that fall at or between <code>left</code> and <code>right</code> could have the keys in them. We then put all the bags between <code>left</code> and <code>mid</code> in the car to test it out. If the car starts up we can set <code>right = mid</code> to lower our upper bound and otherwise set <code>left = mid</code> to raise our lower bound. The falling upper bound and rising lower bound are going to meet at some point and <code>left &lt; right</code> will no longer hold because <code>left == right</code>. At this point we have found our bag!</p>
<p>We can test our function in this program</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff6ac1">from</span> random <span style="color:#ff6ac1">import</span> randint
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff6ac1">def</span> <span style="color:#57c7ff">make_car_start_function</span>(number_of_bags):
</span></span><span style="display:flex;"><span>    <span style="color:#5af78e">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    Creates a car_start function that determines whether the car starts
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    based on the presence of the keys in a subset of bags.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    Parameters:
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    - number_of_bags (int): Total number of bags.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    Returns:
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    - function: A function that takes a list of bag indices and returns True
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">      if the keys are in one of those bags, False otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#78787e"># Randomly select the index of the bag containing the keys</span>
</span></span><span style="display:flex;"><span>    bag_with_keys <span style="color:#ff6ac1">=</span> randint(<span style="color:#ff9f43">0</span>, number_of_bags <span style="color:#ff6ac1">-</span> <span style="color:#ff9f43">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">def</span> <span style="color:#57c7ff">car_start</span>(bags_to_test):
</span></span><span style="display:flex;"><span>        <span style="color:#5af78e">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">        Checks if the keys are in the provided subset of bags.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">        Parameters:
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">        - bags_to_test (list of int): Indices of bags to test.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">        Returns:
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">        - bool: True if the keys are in one of the tested bags, False otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">return</span> bag_with_keys <span style="color:#ff6ac1">in</span> bags_to_test
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">return</span> car_start
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#78787e"># Set up the car_start function for 20 bags</span>
</span></span><span style="display:flex;"><span>car_start <span style="color:#ff6ac1">=</span> make_car_start_function(<span style="color:#ff9f43">20</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#78787e"># Use the binary search function to find the bag with the keys</span>
</span></span><span style="display:flex;"><span>bag_with_keys <span style="color:#ff6ac1">=</span> find_bag_with_keys(<span style="color:#ff9f43">20</span>, car_start)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#78787e"># Print the index of the bag containing the keys</span>
</span></span><span style="display:flex;"><span><span style="color:#ff5c57">print</span>(<span style="color:#5af78e">f</span><span style="color:#5af78e">&#34;The bag with the keys is: </span><span style="color:#5af78e">{</span>bag_with_keys<span style="color:#5af78e">}</span><span style="color:#5af78e">&#34;</span>)
</span></span></code></pre></div><h2 id="performance-analysis">Performance Analysis</h2>
<p>This program works great, and in the graph below we can see the true power of binary search
<style>
    .soft {
        width: 600px;
        border-radius: 10px;
        display: block;
        margin: 0 auto;  
    }
    .image-container {
        text-align: center;
        margin: 20px 0;  
    }
    .caption {
        font-size: 0.9em;
        color: #555;  
        margin-top: 10px;
    }
    .caption a {
        color: #007BFF;  
        text-decoration: none;  
    }
    .caption a:hover {
        text-decoration: underline;  
    }
</style>

<div class="image-container">
    <img src="/img/binarysearch/calls_to_car_start.jpg" class="soft" alt="Soft-styled image">
    
</div>
</p>
<div class="math-container">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.getElementById('block-math-0'), {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "\\(", right: "\\)", display: false }
          ]
        });
      });
    </script>
    <div id="block-math-0" class="math-content">
      
As you can see, the number of calls to car_start is, on average, \(log_2(n)\). This means that even if we had an absurd amount of bags like \(n = 300\), we would only need to try to start the car \(log_2(300) \approx 8\) times. If we naïvely wanted to find our bag by tring to start the car one bag at a time, this would take, on average \(\frac{n}{2}\) calls to start_car. For our case \(n = 300\), \(8\) is much better than \(150\)! Our function runs in \(O(log(n))\) time.

    </div>
  </div>
  
<h1 id="square-roots">Square Roots</h1>
<p>Let&rsquo;s use binary search to tackel a problem that must have been exausting before electronic calculators: root extraction.</p>
<div class="math-container">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.getElementById('block-math-1'), {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "\\(", right: "\\)", display: false }
          ]
        });
      });
    </script>
    <div id="block-math-1" class="math-content">
      
Recall that for a non-negative real number, \(n\), we define the square root of \(n\), \(\sqrt{n}\), as the non-negative real number such that \((\sqrt{n})^2 = n\).

Unlike squaring a number, taking the square root of a number is not straightforward for most all real numbers. In fact, we cannot fully find the square root of most all numbers because the result is irrational and its decimal expansion is an infinite sequence of non-repeating numbers (much to Pythagors's chagrin, \(\sqrt{2}\) is irrational)!  Thas a bummer, but we can find some good appromimations of square roots.

    </div>
  </div>
  
<h2 id="general-approach">General Approach</h2>
<p><style>
    .soft {
        width: 600px;
        border-radius: 10px;
        display: block;
        margin: 0 auto;  
    }
    .image-container {
        text-align: center;
        margin: 20px 0;  
    }
    .caption {
        font-size: 0.9em;
        color: #555;  
        margin-top: 10px;
    }
    .caption a {
        color: #007BFF;  
        text-decoration: none;  
    }
    .caption a:hover {
        text-decoration: underline;  
    }
</style>

<div class="image-container">
    <img src="/img/binarysearch/sqrt.jpg" class="soft" alt="Soft-styled image">
    
    <div class="caption">
        <a href="https://www.desmos.com/">Desmos</a> is great!
    </div>
    
</div>

<div class="math-container">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.getElementById('block-math-2'), {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "\\(", right: "\\)", display: false }
          ]
        });
      });
    </script>
    <div id="block-math-2" class="math-content">
      
We want to make a function that takes in a positive real number, \(n\), and returns its square root. One thing that we can be certain of is that \(\sqrt{n}\) falls somewhere between 0 and \(n\) for \(n > 1\) and somewhere between 0 and 1 for \(n < 1\) (\(\sqrt{n} = 1\) in the case \(n=1\)).

    </div>
  </div>
  </p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff6ac1">def</span> <span style="color:#57c7ff">square_root</span>(n, iterations):
</span></span><span style="display:flex;"><span>    <span style="color:#5af78e">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    Approximates the square root of a number using binary search.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    Parameters:
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    - n (float): The number to find the square root of.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    - iterations (int): The number of iterations to perform for refinement.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    Returns:
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    - float: The approximate square root of the number.
</span></span></span><span style="display:flex;"><span><span style="color:#5af78e">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#78787e"># Define the search range</span>
</span></span><span style="display:flex;"><span>    lower_bound, upper_bound <span style="color:#ff6ac1">=</span> <span style="color:#ff9f43">0</span>, <span style="color:#ff5c57">max</span>(<span style="color:#ff9f43">1</span>, n)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#78787e"># Perform binary search for the specified number of iterations</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">for</span> _ <span style="color:#ff6ac1">in</span> <span style="color:#ff5c57">range</span>(iterations):
</span></span><span style="display:flex;"><span>        midpoint <span style="color:#ff6ac1">=</span> (lower_bound <span style="color:#ff6ac1">+</span> upper_bound) <span style="color:#ff6ac1">/</span> <span style="color:#ff9f43">2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">if</span> midpoint <span style="color:#ff6ac1">**</span> <span style="color:#ff9f43">2</span> <span style="color:#ff6ac1">&gt;</span> n:
</span></span><span style="display:flex;"><span>            upper_bound <span style="color:#ff6ac1">=</span> midpoint  <span style="color:#78787e"># Narrow search to lower half</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">else</span>:
</span></span><span style="display:flex;"><span>            lower_bound <span style="color:#ff6ac1">=</span> midpoint  <span style="color:#78787e"># Narrow search to upper half</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">return</span> lower_bound
</span></span></code></pre></div><p>the first 16 digits of the square root of 2 are <a href="https://nerdparadise.com/math/reference/2sqrt10000">1.414213562373095</a>. We can calculate this with 51 itterations on our function.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff6ac1">&gt;&gt;&gt;</span> square_root(<span style="color:#ff9f43">2</span>, <span style="color:#ff9f43">51</span>)
</span></span><span style="display:flex;"><span><span style="color:#ff9f43">1.414213562373095</span>
</span></span></code></pre></div><p>We are now running up aginst the percision of the float in python, so our current implementation cannot calculate the square root of 2 past this. To get past this would require either a more clever way to hold floating point numbers across multiple variables or modules that give you floating point numbers with more digits like <a href="https://mpmath.org/">mpmath</a>.</p>
<p>Note that every itteration, our range of values that our root can fall within is cut in half, so our error halves at each itteration! Because the place value represented by digits follows an exponential and our error is exponentially decreasing with <code>itterations</code>, a linear increase in itterations leads to a linear increas in the number of correct digits.</p>
<p>This approach for finding the inverse of a function with binary search is not unique to square roots. Can you think of other functions that this will work on? What about functions that it would not work on?</p>
<div class="math-container">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.getElementById('block-math-3'), {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "\\(", right: "\\)", display: false }
          ]
        });
      });
    </script>
    <div id="block-math-3" class="math-content">
      
For those of you with a calculus background, you may know of an even better way to approximate the inverse of functions via Newton's Method. As an extra challenge try to implement the square_root function with Newton's Method. Comapir the convergence to our binary search approach. Which is better? Hint: \(\sqrt{n}\) is a root of the function \(x^2-n\).

    </div>
  </div>
  
<h1 id="main-takeaways">Main Takeaways</h1>
<p>We looked at binary search in both a descret case (finding which bag had the car keys) and in a continuous case (finding the square root of a number). I hope that you have seen that binary search can be a very efficient algorithm compaired to naïve guess and check, especially when we have a large number of items. Binary search is a very general algorithm to have in your toolbox and will come in handy during your CS career.</p>

</main>

  <footer>
  
  
  <hr/>
  © JD Hagood 2025 | <a href="https://github.com/jdhagood/gtl">Github</a>
  
  </footer>
  </body>
</html>

